#include <bits/stdc++.h>
using namespace std;

struct Process {
    int pid, at, bt, pr, ct, tat, wt, rt;
};

// Helper to print results
void print(vector<Process>& p, string name) {
    double total_tat = 0, total_wt = 0;
    cout << "\n--- " << name << " ---\n";
    cout << "PID\tAT\tBT\tCT\tTAT\tWT\n";
    for (auto &x : p) {
        x.tat = x.ct - x.at;
        x.wt = x.tat - x.bt;
        total_tat += x.tat;
        total_wt += x.wt;
        cout << x.pid << "\t" << x.at << "\t" << x.bt << "\t"
             << x.ct << "\t" << x.tat << "\t" << x.wt << "\n";
    }
    cout << fixed << setprecision(2);
    cout << "Average TAT: " << total_tat / p.size() 
         << "\nAverage WT: " << total_wt / p.size() << "\n";
}

// FCFS
void fcfs(vector<Process> p) {
    sort(p.begin(), p.end(), [](auto &a, auto &b){ return a.at < b.at; });
    int t = 0;
    for (auto &x : p) {
        if (t < x.at) t = x.at;
        t += x.bt;
        x.ct = t;
    }
    print(p, "FCFS");
}

// SJF Preemptive (SRTF)
void sjf(vector<Process> p) {
    int n = p.size(), done = 0, t = 0;
    for (auto &x : p) x.rt = x.bt;

    while (done < n) {
        int idx = -1, mn = 1e9;
        for (int i = 0; i < n; i++)
            if (p[i].at <= t && p[i].rt > 0 && p[i].rt < mn)
                mn = p[i].rt, idx = i;

        if (idx == -1) { t++; continue; }

        p[idx].rt--; t++;
        if (p[idx].rt == 0) {
            p[idx].ct = t;
            done++;
        }
    }
    print(p, "SJF (Preemptive)");
}

// Priority Non-Preemptive
void priorityNP(vector<Process> p) {
    int n = p.size(), done = 0, t = 0;
    vector<bool> doneFlag(n, false);
    while (done < n) {
        int idx = -1, best = 1e9;
        for (int i = 0; i < n; i++)
            if (p[i].at <= t && !doneFlag[i] && p[i].pr < best)
                best = p[i].pr, idx = i;

        if (idx == -1) { t++; continue; }
        t += p[idx].bt;
        p[idx].ct = t;
        doneFlag[idx] = true;
        done++;
    }
    print(p, "Priority (Non-Preemptive)");
}

// Round Robin
void rr(vector<Process> p, int q) {
    int n = p.size(), t = 0, done = 0;
    queue<int> qx;
    for (auto &x : p) x.rt = x.bt;
    sort(p.begin(), p.end(), [](auto &a, auto &b){ return a.at < b.at; });
    int i = 0;
    qx.push(0);

    while (done < n) {
        if (qx.empty()) { 
            if (i < n) qx.push(i++); 
            else break;
        }
        int idx = qx.front(); qx.pop();
        int exec = min(q, p[idx].rt);
        t = max(t, p[idx].at) + exec;
        p[idx].rt -= exec;

        // Add new arrivals
        while (i < n && p[i].at <= t) qx.push(i++);

        if (p[idx].rt == 0) {
            p[idx].ct = t;
            done++;
        } else qx.push(idx);
    }
    print(p, "Round Robin (q=" + to_string(q) + ")");
}

int main() {
    vector<Process> p = {
        {1, 0, 10, 3}, {2, 1, 5, 1}, {3, 2, 2, 4}, {4, 3, 4, 2}, {5, 5, 8, 5}
    };
    cout << "PID\tAT\tBT\tPR\n";
    for (auto &x : p)
        cout << x.pid << "\t" << x.at << "\t" << x.bt << "\t" << x.pr << "\n";

    fcfs(p);
    sjf(p);
    priorityNP(p);
    rr(p, 3);
}
